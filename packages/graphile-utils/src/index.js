import graphqlTag from "graphql-tag";

const $$embed = Symbol("graphile-embed");

export function isEmbed(obj) {
  return obj && obj[$$embed] === true;
}

export function embed(value) {
  return {
    [$$embed]: true,
    value,
  };
}

export function gql(strings, ...placeholders) {
  const gqlStrings = [];
  const gqlValues = [];
  let currentString = "";
  for (let idx = 0, length = strings.length; idx < length; idx++) {
    currentString += strings[idx];
    if (idx === length - 1) {
      gqlStrings.push(currentString);
    } else {
      if (isEmbed(placeholders[idx])) {
        gqlValues.push(placeholders[idx].value);
        gqlStrings.push(currentString);
        currentString = "";
      } else {
        if (typeof placeholders[idx] !== "string") {
          throw new Error(
            `Placeholder ${idx +
              1} is invalid - expected string, but received '${typeof placeholders[
              idx
            ]}'. Happened after '${currentString}'`
          );
        }
        currentString += String(placeholders[idx]);
      }
    }
  }
  return graphqlTag(gqlStrings, ...gqlValues);
}

export function ExtendSchemaPlugin(generator) {
  function getName(name) {
    if (name && name.kind === "Name" && name.value) {
      return name.value;
    }
    throw new Error("Could not extract name from AST");
  }

  function getDescription(desc) {
    if (!desc) {
      return null;
    } else if (desc.kind === "StringValue") {
      return desc.value;
    } else {
      throw new Error(
        `AST issue, we weren't expecting a description of kind '${
          desc.kind
        }' - PRs welcome!`
      );
    }
  }

  function getType(type, build) {
    if (type.kind === "NamedType") {
      return build.getTypeByName(getName(type.name));
    } else if (type.kind === "NonNullType") {
      return new build.graphql.GraphQLNonNull(getType(type.type, build));
    } else if (type.kind === "ListType") {
      return new build.graphql.GraphQLList(getType(type.type, build));
    } else {
      throw new Error(
        `We don't support AST type definition of kind '${
          type.kind
        }' yet... PRs welcome!`
      );
    }
  }

  function getInterfaces(interfaces, build) {
    if (interfaces.length) {
      throw new Error(
        `We don't support interfaces via ExtendSchemaPlugin yet; PRs welcome!`
      );
    }
    return [];
  }

  function getArguments(args, build) {
    if (args.length) {
      throw new Error(
        `We don't support interfaces via ExtendSchemaPlugin yet; PRs welcome!`
      );
    }
    return {};
  }

  return builder => {
    // Add stuff to the schema
    builder.hook("build", build => {
      const { typeDefs, resolvers = {} } = generator(build);
      if (!typeDefs || !typeDefs.kind === "Document") {
        throw new Error(
          "The first argument to ExtendSchemaPlugin must be generated by the `gql` helper"
        );
      }
      const objectExtensions = {};
      typeDefs.definitions.forEach(definition => {
        if (definition.kind === "ObjectTypeExtension") {
          const name = getName(definition.name);
          if (!objectExtensions[name]) {
            objectExtensions[name] = [];
          }
          objectExtensions[name].push(definition);
        } else {
          throw new Error(
            `Unexpected '${
              definition.kind
            }' definition; we were expecting 'ObjectTypeExtension', i.e. something like 'extend type Foo { ... }'`
          );
        }
      });
      return build.extend(build, {
        ExtendSchemaPlugin_objectExtensions: objectExtensions,
        ExtendSchemaPlugin_resolvers: resolvers,
      });
    });
    //const interfaces = getInterfaces(extension.interfaces, build);

    builder.hook("GraphQLObjectType:fields", (fields, build, context) => {
      const {
        extend,
        ExtendSchemaPlugin_objectExtensions: objectExtensions,
        ExtendSchemaPlugin_resolvers: resolvers,
      } = build;
      const { Self, fieldWithHooks } = context;
      if (objectExtensions[Self.name]) {
        const newFields = objectExtensions[Self.name].reduce(
          (memo, extension) => {
            const fields = extension.fields;
            if (fields && fields.length) {
              fields.forEach(field => {
                if (field.kind === "FieldDefinition") {
                  const description = getDescription(field.description);
                  const fieldName = getName(field.name);
                  const args = getArguments(field.arguments, build);
                  const type = getType(field.type, build);
                  const scope = {
                    // TODO: add directives here!
                  };
                  const deprecationReason = null; // TODO: extract from directive!
                  const resolve =
                    (resolvers[Self.name] && resolvers[Self.name][fieldName]) ||
                    null;
                  memo[fieldName] = fieldWithHooks(
                    fieldName,
                    {
                      type,
                      args,
                      resolve,
                      deprecationReason,
                      description,
                    },
                    scope
                  );
                } else {
                  throw new Error(
                    `AST issue: expected 'FieldDefinition', instead received '${
                      field.kind
                    }'`
                  );
                }
              });
            }
            return memo;
          },
          {}
        );
        // EXTEND!
        return extend(fields, newFields);
      } else {
        return fields;
      }
    });
  };
}
