import { ExtendSchemaPlugin, AddInflectorsPlugin, gql, embed } from "../src";
import {
  buildSchema,
  // defaultPlugins,
  StandardTypesPlugin,
  QueryPlugin,
  MutationPlugin,
  MutationPayloadQueryPlugin,
} from "graphile-build";
import { graphql, printSchema } from "graphql";

function TestUtils_ExtractScopePlugin(
  hook,
  objectTypeName,
  fieldNameOrCallback,
  possiblyCallback
) {
  const callback =
    typeof fieldNameOrCallback === "function" && !possiblyCallback
      ? fieldNameOrCallback
      : possiblyCallback;
  const fieldName = possiblyCallback && fieldNameOrCallback;
  return builder => {
    builder.hook(hook, (_, build, context) => {
      const { Self } = context;
      const currentObjectTypeName = (Self && Self.name) || _.name;
      const currentFieldName = Self ? context.scope.fieldName : undefined;
      if (
        currentObjectTypeName === objectTypeName &&
        (!fieldName || fieldName === currentFieldName)
      ) {
        callback(context.scope);
      }
      return _;
    });
  };
}

const simplePlugins = [
  StandardTypesPlugin,
  QueryPlugin,
  MutationPlugin,
  MutationPayloadQueryPlugin,
];

const resolvers = {
  Query: {
    randomNumber(_query, _args, _context, _info) {
      return 4; // chosen by fair dice roll. guaranteed to be random. xkcd#221
    },
    randomNumbers() {
      return [5, 3, 6];
    },
    echo(_query, args) {
      return args.input;
    },
  },
};

it("allows adding a simple type", async () => {
  const schema = await buildSchema([
    ...simplePlugins,
    ExtendSchemaPlugin(_build => ({
      typeDefs: gql`
        extend type Query {
          """
          A random number generated by a fair dice roll.
          """
          randomNumber: Int
        }
      `,
      resolvers,
    })),
  ]);
  const printedSchema = printSchema(schema);
  expect(printedSchema).toMatchSnapshot();
  const { data } = await graphql(
    schema,
    `
      {
        randomNumber
      }
    `
  );
  expect(data.randomNumber).toEqual(4);
});

it("allows adding a non-null type", async () => {
  const schema = await buildSchema([
    ...simplePlugins,
    ExtendSchemaPlugin(_build => ({
      typeDefs: gql`
        extend type Query {
          """
          A random number generated by a fair dice roll.
          """
          randomNumber: Int!
        }
      `,
      resolvers,
    })),
  ]);
  const printedSchema = printSchema(schema);
  expect(printedSchema).toMatchSnapshot();
  const { data } = await graphql(
    schema,
    `
      {
        randomNumber
      }
    `
  );
  expect(data.randomNumber).toEqual(4);
});

it("allows adding a non-null list of non-null type", async () => {
  const schema = await buildSchema([
    ...simplePlugins,
    ExtendSchemaPlugin(_build => ({
      typeDefs: gql`
        extend type Query {
          """
          Gives a list of numbers that were randomly generated by fair dice roll
          """
          randomNumbers: [Int!]!
        }
      `,
      resolvers,
    })),
  ]);
  const printedSchema = printSchema(schema);
  expect(printedSchema).toMatchSnapshot();
  const { data } = await graphql(
    schema,
    `
      {
        randomNumbers
      }
    `
  );
  expect(data.randomNumbers).toEqual([5, 3, 6]);
});

it("allows adding a field with arguments", async () => {
  const schema = await buildSchema([
    ...simplePlugins,
    ExtendSchemaPlugin(_build => ({
      typeDefs: gql`
        extend type Query {
          """
          Gives you back what you put in
          """
          echo(input: [Int!]!): [Int!]!
        }
      `,
      resolvers,
    })),
  ]);
  const printedSchema = printSchema(schema);
  expect(printedSchema).toMatchSnapshot();
  const { data } = await graphql(
    schema,
    `
      {
        echo(input: [1, 1, 2, 3, 5, 8])
      }
    `
  );
  expect(data.echo).toEqual([1, 1, 2, 3, 5, 8]);
});

it("allows adding a field with arguments named using a custom inflector", async () => {
  const schema = await buildSchema([
    ...simplePlugins,
    AddInflectorsPlugin({
      echoFieldName() {
        return this.camelCase("my-custom-echo-field-name");
      },
    }),
    ExtendSchemaPlugin(build => ({
      typeDefs: gql`
        extend type Query {
          """
          Gives you back what you put in
          """
          ${build.inflection.echoFieldName()}(input: [Int!]!): [Int!]!
        }
      `,
      resolvers: {
        Query: {
          [build.inflection.echoFieldName()]: resolvers.Query.echo,
        },
      },
    })),
  ]);
  const printedSchema = printSchema(schema);
  expect(printedSchema).toMatchSnapshot();
  const { data, errors } = await graphql(
    schema,
    `
      {
        echo: myCustomEchoFieldName(input: [1, 1, 2, 3, 5, 8])
      }
    `
  );
  expect(errors).toBeFalsy();
  expect(data.echo).toEqual([1, 1, 2, 3, 5, 8]);
});

it("supports @scope directive with simple values", async () => {
  let scope;
  function storeScope(_scope) {
    if (scope) {
      throw new Error("Scope already stored!");
    }
    scope = _scope;
  }
  const schema = await buildSchema([
    ...simplePlugins,
    ExtendSchemaPlugin(_build => ({
      typeDefs: gql`
        extend type Query {
          """
          Gives you back what you put in
          """
          echo(input: [Int!]!): [Int!]!
            @scope(
              isEchoField: true
              stringTest: "THIS_IS_A_STRING"
              intTest: 42
              floatTest: 3.141592
              nullTest: null
            )
        }
      `,
      resolvers,
    })),
    TestUtils_ExtractScopePlugin(
      "GraphQLObjectType:fields:field",
      "Query",
      "echo",
      storeScope
    ),
  ]);
  expect(scope).toBeTruthy();
  expect(scope.isEchoField).toEqual(true);
  expect(scope.stringTest).toEqual("THIS_IS_A_STRING");
  expect(scope.intTest).toEqual(42);
  expect(scope.floatTest).toEqual(3.141592);
  expect(scope.nullTest).toEqual(null);
  expect(scope).toMatchSnapshot();
  const printedSchema = printSchema(schema);
  expect(printedSchema).toMatchSnapshot();
  const { data, errors } = await graphql(
    schema,
    `
      {
        echo(input: [1, 1, 2, 3, 5, 8])
      }
    `
  );
  expect(errors).toBeFalsy();
  expect(data.echo).toEqual([1, 1, 2, 3, 5, 8]);
});

it("supports @scope directive with variable value", async () => {
  let scope;
  function storeScope(_scope) {
    if (scope) {
      throw new Error("Scope already stored!");
    }
    scope = _scope;
  }
  const secret = Symbol("test-secret");
  const schema = await buildSchema([
    ...simplePlugins,
    ExtendSchemaPlugin(_build => ({
      typeDefs: gql`
        extend type Query {
          """
          Gives you back what you put in
          """
          echo(input: [Int!]!): [Int!]!
            @scope(
              isEchoField: true
              stringTest: "THIS_IS_A_STRING"
              intTest: 42
              floatTest: 3.141592
              nullTest: null
              embedTest: ${embed({
                [secret]: "Fred",
                sub: [[11, 22], [33, 44]],
              })}
            )
        }
      `,
      resolvers,
    })),
    TestUtils_ExtractScopePlugin(
      "GraphQLObjectType:fields:field",
      "Query",
      "echo",
      storeScope
    ),
  ]);
  expect(scope).toBeTruthy();
  expect(scope.isEchoField).toEqual(true);
  expect(scope.stringTest).toEqual("THIS_IS_A_STRING");
  expect(scope.intTest).toEqual(42);
  expect(scope.floatTest).toEqual(3.141592);
  expect(scope.nullTest).toEqual(null);
  expect(scope.embedTest).toBeTruthy();
  expect(scope.embedTest[secret]).toEqual("Fred");
  expect(scope.embedTest.sub[1][1]).toEqual(44);
  expect(scope).toMatchSnapshot();
  const printedSchema = printSchema(schema);
  expect(printedSchema).toMatchSnapshot();
  const { data, errors } = await graphql(
    schema,
    `
      {
        echo(input: [1, 1, 2, 3, 5, 8])
      }
    `
  );
  expect(errors).toBeFalsy();
  expect(data.echo).toEqual([1, 1, 2, 3, 5, 8]);
});

it("supports defining new types", async () => {
  const schema = await buildSchema([
    ...simplePlugins,
    ExtendSchemaPlugin(_build => ({
      typeDefs: gql`
        input EchoInput {
          text: String!
          int: Int
          float: Float!
        }

        type EchoOutput {
          text: String!
          int: Int
          float: Float!
        }

        extend input EchoInput {
          intList: [Int!]
        }

        extend type EchoOutput {
          intList: [Int!]
        }

        extend type Query {
          """
          Gives you back what you put in
          """
          echo(input: EchoInput): EchoOutput
        }
      `,
      resolvers: {
        Query: {
          echo(_query, args) {
            return args.input;
          },
        },
      },
    })),
  ]);
  const printedSchema = printSchema(schema);
  expect(printedSchema).toMatchSnapshot();
  const { data, errors } = await graphql(
    schema,
    `
      {
        t1: echo(input: { text: "Hi1", float: 0.23 }) {
          text
          int
          float
          intList
        }
        t2: echo(input: { text: "Hi2", int: 42, float: 1.23 }) {
          text
          int
          float
          intList
        }
        t3: echo(
          input: { text: "Hi3", int: 88, float: 2.23, intList: [99, 22, 33] }
        ) {
          text
          int
          float
          intList
        }
      }
    `
  );
  expect(errors).toBeFalsy();
  expect(data).toMatchSnapshot();
});
