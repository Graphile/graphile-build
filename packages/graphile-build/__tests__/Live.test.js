import {
  LiveSource,
  LiveCoordinator,
  LiveProvider,
  makeAsyncIteratorFromMonitor,
} from "../src/Live";

// TODO: this file needs a *lot* more tests!

class DummyProvider extends LiveProvider {
  constructor() {
    super();
    this.namespace = "dummy";
  }

  collectionIdentifierIsValid() {
    return true;
  }

  recordIdentifierIsValid() {
    return true;
  }
}

class DummySource extends LiveSource {
  constructor() {
    super();
    this.collectionListeners = [];
    this.recordListeners = [];
  }

  subscribeCollection(callback, collectionIdentifier, predicate) {
    const entry = [callback, collectionIdentifier, predicate];
    this.collectionListeners.push(entry);
    return () => {
      const i = this.collectionListeners.indexOf(entry);
      if (i >= 0) {
        this.collectionListeners.splice(i, 1);
      }
    };
  }

  subscribeRecord(callback, collectionIdentifier, recordIdentifier) {
    const entry = [callback, collectionIdentifier, recordIdentifier];
    this.recordListeners.push(entry);
    return () => {
      const i = this.recordListeners.indexOf(entry);
      if (i >= 0) {
        this.recordListeners.splice(i, 1);
      }
    };
  }

  triggerRecord(collectionIdentifier, recordIdentifier) {
    for (const rl of this.recordListeners) {
      const [rlCallback, rlCollectionIdentifier, rlRecordIdentifier] = rl;
      if (
        collectionIdentifier === rlCollectionIdentifier &&
        recordIdentifier === rlRecordIdentifier
      ) {
        rlCallback({ collectionIdentifier, recordIdentifier });
      }
    }
  }
}

const dummySource = new DummySource();

test("works", async () => {
  const lc = new LiveCoordinator();
  const dummyProvider = new DummyProvider();
  lc.registerProvider(dummyProvider);
  lc.registerSource("dummy", dummySource);
  const { monitor, context } = lc.getMonitorAndContext();
  const asyncIterator = makeAsyncIteratorFromMonitor(monitor);
  expect(Object.keys(context)).toMatchInlineSnapshot(`
Array [
  "liveCollection",
  "liveRecord",
  "liveConditions",
]
`);
  const collection = Symbol("collection");
  const record = Symbol("record");

  // Async iterator always immediately triggers
  {
    const { value, done } = await asyncIterator.next();
    expect(done).toBeFalsy();
    expect(value).toMatchInlineSnapshot(`undefined`);
  }

  // Now we register a listener
  monitor.liveRecord("dummy", collection, record);
  // And trigger an update to it
  dummySource.triggerRecord(collection, record);
  // Which should mean we trigger again
  {
    const { value, done } = await asyncIterator.next();
    expect(done).toBeFalsy();
    expect(value).toMatchInlineSnapshot(`undefined`);
  }

  // Now we should have reset again (because we triggered), so if we trigger
  // another update it won't do anything
  dummySource.triggerRecord(collection, record);
  // So if we return
  asyncIterator.return();
  // Then done should be true immediately (no intermediate values generated by the above triggerRecord)
  {
    const { value, done } = await asyncIterator.next();
    expect(done).toBeTruthy();
    expect(value).toMatchInlineSnapshot(`undefined`);
  }
});
